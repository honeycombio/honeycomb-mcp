import { z } from "zod";
import { HoneycombAPI } from "../api/client.js";
import { handleToolError } from "../utils/tool-error.js";
import { QueryToolSchema } from "../types/schema.js";
import { summarizeResults } from "../utils/transformations.js";

/**
 * Tool to run a query against a Honeycomb dataset
 */
export function createRunQueryTool(api: HoneycombAPI) {
  return {
    name: "run_query",
    schema: QueryToolSchema.shape,
    handler: async (params: z.infer<typeof QueryToolSchema>) => {
      try {
        // Validate calculation and operation combinations
        const hasHeatmap = params.calculations.some(calc => calc.op === "HEATMAP");
        
        // Get all calculation identifiers for validation
        const calculationIds = params.calculations.map(calc => {
          if (calc.op === "COUNT" || calc.op === "CONCURRENCY") {
            return calc.op;
          }
          return `${calc.op}(${calc.column})`;
        });
        
        // Validate orders if they reference calculations or breakdowns
        if (params.orders) {
          const calculationOps = params.calculations.map(calc => calc.op);
          const validOrderOps = [...calculationOps];
          
          // Add COUNT and CONCURRENCY if not already in calculationOps
          if (!validOrderOps.includes("COUNT")) validOrderOps.push("COUNT");
          if (!validOrderOps.includes("CONCURRENCY")) validOrderOps.push("CONCURRENCY");
          
          // Check if orders reference valid operations
          for (const order of params.orders) {
            // Per docs: "The ORDER BY clauses available to you for a particular query are influenced by 
            // whether any GROUP BY or VISUALIZE clauses are also specified. If none are, you may order 
            // by any of the attributes contained in the dataset. However, once a GROUP BY or VISUALIZE 
            // clause exists, you may only order by the values generated by those clauses."
            if (order.column && !params.breakdowns?.includes(order.column) && 
                !params.calculations.some(calc => calc.column === order.column)) {
              throw new Error(`Order column '${order.column}' must be in breakdowns or calculations. According to Honeycomb docs, once a GROUP BY (breakdowns) or VISUALIZE (calculations) clause exists, you may only order by the values generated by those clauses.`);
            }
            
            if (order.op === "HEATMAP") {
              throw new Error("HEATMAP cannot be used in orders as specified in Honeycomb's documentation.");
            }
            
            if (!order.column && !["COUNT", "CONCURRENCY"].includes(order.op)) {
              throw new Error(`Operation '${order.op}' requires a column unless it is COUNT or CONCURRENCY.`);
            }
          }
        }
        
        // Validate having clauses
        if (params.having) {
          for (const having of params.having) {
            // Per docs: "The HAVING clause always refers to one of the VISUALIZE clauses."
            // Ensure the calculate_op + column combination exists in calculations
            const havingOpId = having.column 
              ? `${having.calculate_op}(${having.column})` 
              : having.calculate_op;
              
            const matchingCalculation = params.calculations.some(calc => {
              if ((calc.op === "COUNT" || calc.op === "CONCURRENCY") && 
                  having.calculate_op === calc.op) {
                return true;
              }
              
              return calc.op === having.calculate_op && calc.column === having.column;
            });
            
            if (!matchingCalculation) {
              throw new Error(`HAVING clause with calculate_op '${having.calculate_op}' ${having.column ? `and column '${having.column}'` : ''} must refer to one of the VISUALIZE (calculations) clauses. Available calculations: ${calculationIds.join(', ')}`);
            }
          }
        }
        
        // Handle time parameters
        if (params.start_time && params.end_time && params.time_range) {
          // Cannot have all three
          throw new Error("Cannot specify time_range, start_time, and end_time simultaneously. Use time_range with either start_time or end_time, or use start_time and end_time without time_range.");
        }

        const result = await api.runAnalysisQuery(params.environment, params.dataset, params);
        
        // Simplify the response to reduce context window usage
        const simplifiedResponse = {
          results: result.data?.results || [],
          // Only include series data if heatmap calculation is present (it's usually large)
          ...(hasHeatmap ? { series: result.data?.series || [] } : {}),
          
          // Include a query URL if available 
          query_url: result.links?.query_url || null,
          
          // Add summary statistics for numeric columns
          summary: summarizeResults(result.data?.results || [], params)
        };
        
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(simplifiedResponse, null, 2),
            },
          ],
        };
      } catch (error) {
        return handleToolError(error, "run_query");
      }
    }
  };
}
